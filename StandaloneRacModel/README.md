# 轻量化飞行动力学模型之二: RacModel

RacModel核心目的不是为了精确模拟飞行的物理过程，而是为了让一个飞行器实体（通常是AI或脚本控制的）能够**可信地、自动地飞向一个给定的目标状态**（即指令高度、指令航向和指令速度）。

### `RacModel` 的核心作用与特点

1.  **行为驱动 (Behavior-Driven)**
    `RacModel`的逻辑完全基于“误差修正”。它计算当前状态与指令状态之间的差距，并以此为依据来生成机动动作。

      * **高度控制**: 它通过计算指令高度与实际高度的差值来确定一个期望的垂直速度 `cmdAltRate`。
        ```cpp
        // RacModel.cpp
        double cmdAltRate = (cmdAltitude - pp->getAltitudeM()); 
        ```
      * **航向控制**: 它通过计算指令航向与实际航向的差值来确定一个期望的转弯速率 `ra`。
        ```cpp
        // RacModel.cpp
        double ra = base::angle::aepcdRad((cmdHeading * base::angle::D2RCC) - pp->getHeadingR()) * 0.1;
        ```

2.  **运动学模型 (Kinematic Model)**
    与高保真模型不同，`RacModel`不涉及复杂的空气动力、力或力矩的计算。它直接在运动学层面工作，计算出需要的角速度和线加速度，然后通过积分直接更新飞行器的姿态和速度。

      * 它根据期望的俯仰角和转弯率，直接积分计算出新的俯仰 `newTheta` 和偏航 `newPsi`。
        ```cpp
        // RacModel.cpp
        double newTheta = static_cast<double>(pp->getPitch() + (qa + qa1) * dt / 2.0);
        double newPsi = static_cast<double>(pp->getHeading() + (ra + ra1) * dt / 2.0);
        ```

3.  **性能受限 (Performance-Limited)**
    为了使飞行看起来真实可信，`RacModel`的所有机动都受到一组可配置的性能参数的限制。这可以防止飞机做出违反物理规律的瞬时转向或加减速。

      * **可配置参数**: `RacModel`可以通过“槽位”(Slots)从外部配置文件中加载性能限制，如最小速度、最大G值、最大加速度等。
        ```cpp
        // RacModel.cpp -> BEGIN_SLOTTABLE
        "minSpeed",    // 1 Minimum Velocity        (kts)
        "speedMaxG",   // 2 Velocity we reach max G (kts)
        "maxg",        // 3 Max G's (at "speedMaxG" or above)
        "maxAccel",    // 4 Maximum Acceleration    (m/s/s)
        ```
      * **限制应用**: 在计算中，模型会确保转弯率不超过最大G值允许的范围 `ra_max`，加速度不超过 `maxAccel`。

4.  **为AI/脚本设计 (Designed for AI/Scripting)**
    `RacModel`的整个设计哲学都非常适合计算机控制的实体。它可以接收简单的指令，然后自主完成复杂的飞行过程，是理想的“机器人飞机”（Robot Aircraft）控制器。

      * 它实现了完整的自动驾驶仪接口，如 `setCommandedHeadingD`, `setCommandedAltitude`, `setCommandedVelocityKts`，允许外部逻辑（如AI决策层）轻松地向其下达指令。



### RacModel vs. LaeroModel: 核心区别

尽管这两个模型最终都实现了对飞行器的六自由度（6-DOF）状态更新，并且都能用于轨迹跟踪，但它们的**设计哲学、控制逻辑和最终的飞行表现**存在本质上的不同。

| 对比维度 | `StandaloneRacModel` | `StandaloneLaeroModel` |
| :--- | :--- | :--- |
| **设计哲学** | **行为驱动的自动驾驶仪 (Behavior-Driven Autopilot)** | **简化的飞行动力学模型 (Simplified Flight Dynamics)** |
| **核心逻辑** | 以**"误差最小化"**为目标，直接根据当前状态与指令状态的差距，计算出需要执行的**角速度**和**加速度**。 | 以**"状态分层控制"**为逻辑，将高层指令（如飞向某航向）分解为中间层的姿态目标（如滚转到某个坡度），再由底层控制器实现该姿态。 |
| 转弯机理 | 直接控制偏航率：`航向误差 -> 计算期望的偏航速率(ra) -> 直接应用`。飞机的转弯更像是“原地旋转”，滚转角（坡度）只是为了视觉效果而附加的副产品。 | 通过滚转实现转弯 (Bank-to-Turn)：`航向误差 -> 计算期望的偏航率 -> 计算实现该偏航率所需的滚转角(坡度) -> 控制飞机滚转到该坡度 -> 因坡度产生向心力从而实现转弯`。 |
| 物理可信度 | 较低。由于是直接控制偏航率，其转弯动作可能看起来不自然，像一个“会飞的炮塔”，尤其是在低速时。但其行为非常直接和可预测。 | 较高。其“滚转-转弯”机制符合真实飞机的基本飞行原理，因此飞行姿态和轨迹在视觉上更平滑、更可信。 |
| 可调参数 | 侧重于**性能包线**的限制：<br>- `gMax` (最大G值)<br>- `maxAccel` (最大加速度)<br>- `vpMinKts` (最小速度) | 侧重于**控制律**的调节：<br>- `TAU` (时间常数，影响响应平滑度)<br>- `maxBankD` (最大坡度)<br>- `maxPitchD` (最大俯仰角) |
| **内部复杂度** | **相对简单**。逻辑直接，从误差到输出的链路短。 | **相对复杂**。控制链条更长（指令-\>姿态目标-\>姿态率），各环节相互关联。 |

-----

### 使用场景与选择建议

#### 何时选择 `StandaloneRacModel`?

选择 `RacModel` 当您的关注点在于 **任务的完成度和行为的可预测性**，而不是飞行的“质感”。

**典型应用场景**:

1.  **大规模AI集群仿真**: 当您需要模拟成百上千个AI飞机、无人机或导弹时，`RacModel` 的计算效率高、行为直接，非常适合作为这些实体的“大脑”。
2.  **严格的脚本化飞行**: 如果您需要一个飞行器严格按照预设的脚本（如特定时间到达特定位置）飞行，`RacModel` 的直接控制特性使其更容易达到目标。
3.  **高级AI的上层控制**: 当您有一个更复杂的高级AI决策层时，`RacModel` 可以作为一个可靠的“底层执行器”。高级AI只负责下达简单的“飞向xx”指令，而无需关心飞行的具体实现。
4.  **非飞机实体模拟**: 它的逻辑也可以很方便地迁移到需要姿态控制的船只、潜艇等其他载具上。

**一句话总结**: 当您把飞行器看作一个需要完成任务的“机器人”时，请选择 `RacModel`。

#### 何时选择 `StandaloneLaeroModel`?

选择 `LaeroModel` 当您更关心 **飞行的视觉效果、物理直觉和“手感”**。

**典型应用场景**:

1.  **轻量级/街机风格的飞行游戏**: 当玩家或重要的AI僚机需要展示出符合直觉的飞行动作（如漂亮的压坡转弯）时，`LaeroModel` 能提供更好的视觉体验。
2.  **对飞行质感有要求的AI**: 例如，AI僚机或敌机，您希望它们的飞行动作看起来更像是“人类飞行员”在驾驶，而不是冷冰冰的机器人。
3.  **快速原型验证**: 在开发早期，用于快速验证一个飞行概念或游戏玩法，它在性能和真实性之间取得了很好的平衡。

**一句话总结**: 当您希望飞行器表现得更像一个“飞机”而不是机器人时，请选择 `StandaloneLaeroModel`。

### 快速参考摘要

| 特性 | `StandaloneRacModel` | `StandaloneLaeroModel` |
| :--- | :--- | :--- |
| **核心** | 行为驱动的自动驾驶仪 | 简化的飞行动力学 |
| **优点** | 逻辑直接，行为可预测，易于控制 | 飞行姿态自然，视觉效果好 |
| **缺点** | 飞行质感较差，可能出现不自然机动 | 控制链条长，参数调节可能更复杂 |
| **典型应用** | 大规模AI，脚本化任务，导弹 | 街机游戏，AI僚机，视觉展示 |
